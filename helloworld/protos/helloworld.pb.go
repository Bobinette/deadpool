// Code generated by protoc-gen-go.
// source: helloworld.proto
// DO NOT EDIT!

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	helloworld.proto

It has these top-level messages:
	IdMessage
	ConnectRequest
	ConnectReply
	LeaveReply
	Notification
	PlayRequest
	PlayReply
*/
package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// ---- General message - Could be better named
type IdMessage struct {
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *IdMessage) Reset()                    { *m = IdMessage{} }
func (m *IdMessage) String() string            { return proto.CompactTextString(m) }
func (*IdMessage) ProtoMessage()               {}
func (*IdMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ---- Connect
type ConnectRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ConnectReply struct {
	// Id of the player
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *ConnectReply) Reset()                    { *m = ConnectReply{} }
func (m *ConnectReply) String() string            { return proto.CompactTextString(m) }
func (*ConnectReply) ProtoMessage()               {}
func (*ConnectReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// ---- Leave
type LeaveReply struct {
	// Time spent on the server in ms
	Time int64 `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
}

func (m *LeaveReply) Reset()                    { *m = LeaveReply{} }
func (m *LeaveReply) String() string            { return proto.CompactTextString(m) }
func (*LeaveReply) ProtoMessage()               {}
func (*LeaveReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// ---- Notification
type Notification struct {
	// Max number of players
	MaxPlayers int32 `protobuf:"varint,1,opt,name=max_players,json=maxPlayers" json:"max_players,omitempty"`
	NPlayers   int32 `protobuf:"varint,2,opt,name=n_players,json=nPlayers" json:"n_players,omitempty"`
	// Name of the player joind the world
	Joined string `protobuf:"bytes,3,opt,name=joined" json:"joined,omitempty"`
	// Name of the player leaving the world
	Left string `protobuf:"bytes,4,opt,name=left" json:"left,omitempty"`
	// Game specific fields
	Message  string `protobuf:"bytes,5,opt,name=message" json:"message,omitempty"`
	Author   string `protobuf:"bytes,6,opt,name=author" json:"author,omitempty"`
	AuthorId int32  `protobuf:"varint,7,opt,name=author_id,json=authorId" json:"author_id,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// ---- Play
type PlayRequest struct {
	// Id of the player
	Id int32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Message to transmit
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *PlayRequest) Reset()                    { *m = PlayRequest{} }
func (m *PlayRequest) String() string            { return proto.CompactTextString(m) }
func (*PlayRequest) ProtoMessage()               {}
func (*PlayRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type PlayReply struct {
	// Accepted status
	Accepted bool `protobuf:"varint,1,opt,name=accepted" json:"accepted,omitempty"`
	// Response message
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *PlayReply) Reset()                    { *m = PlayReply{} }
func (m *PlayReply) String() string            { return proto.CompactTextString(m) }
func (*PlayReply) ProtoMessage()               {}
func (*PlayReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func init() {
	proto.RegisterType((*IdMessage)(nil), "helloworld.IdMessage")
	proto.RegisterType((*ConnectRequest)(nil), "helloworld.ConnectRequest")
	proto.RegisterType((*ConnectReply)(nil), "helloworld.ConnectReply")
	proto.RegisterType((*LeaveReply)(nil), "helloworld.LeaveReply")
	proto.RegisterType((*Notification)(nil), "helloworld.Notification")
	proto.RegisterType((*PlayRequest)(nil), "helloworld.PlayRequest")
	proto.RegisterType((*PlayReply)(nil), "helloworld.PlayReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for HelloWorld service

type HelloWorldClient interface {
	// Connects to the server to get an id to use in other messages
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*IdMessage, error)
	// Let the server know the client is leaving
	Leave(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (*LeaveReply, error)
	// Subscribe to server-side stream
	Subscribe(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (HelloWorld_SubscribeClient, error)
	// Request a notification from the server
	GetNotification(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (*Notification, error)
	// Let the server know the client's move for the game
	Play(ctx context.Context, in *PlayRequest, opts ...grpc.CallOption) (*PlayReply, error)
}

type helloWorldClient struct {
	cc *grpc.ClientConn
}

func NewHelloWorldClient(cc *grpc.ClientConn) HelloWorldClient {
	return &helloWorldClient{cc}
}

func (c *helloWorldClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*IdMessage, error) {
	out := new(IdMessage)
	err := grpc.Invoke(ctx, "/helloworld.HelloWorld/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *helloWorldClient) Leave(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (*LeaveReply, error) {
	out := new(LeaveReply)
	err := grpc.Invoke(ctx, "/helloworld.HelloWorld/Leave", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *helloWorldClient) Subscribe(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (HelloWorld_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_HelloWorld_serviceDesc.Streams[0], c.cc, "/helloworld.HelloWorld/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &helloWorldSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type HelloWorld_SubscribeClient interface {
	Recv() (*Notification, error)
	grpc.ClientStream
}

type helloWorldSubscribeClient struct {
	grpc.ClientStream
}

func (x *helloWorldSubscribeClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *helloWorldClient) GetNotification(ctx context.Context, in *IdMessage, opts ...grpc.CallOption) (*Notification, error) {
	out := new(Notification)
	err := grpc.Invoke(ctx, "/helloworld.HelloWorld/GetNotification", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *helloWorldClient) Play(ctx context.Context, in *PlayRequest, opts ...grpc.CallOption) (*PlayReply, error) {
	out := new(PlayReply)
	err := grpc.Invoke(ctx, "/helloworld.HelloWorld/Play", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HelloWorld service

type HelloWorldServer interface {
	// Connects to the server to get an id to use in other messages
	Connect(context.Context, *ConnectRequest) (*IdMessage, error)
	// Let the server know the client is leaving
	Leave(context.Context, *IdMessage) (*LeaveReply, error)
	// Subscribe to server-side stream
	Subscribe(*IdMessage, HelloWorld_SubscribeServer) error
	// Request a notification from the server
	GetNotification(context.Context, *IdMessage) (*Notification, error)
	// Let the server know the client's move for the game
	Play(context.Context, *PlayRequest) (*PlayReply, error)
}

func RegisterHelloWorldServer(s *grpc.Server, srv HelloWorldServer) {
	s.RegisterService(&_HelloWorld_serviceDesc, srv)
}

func _HelloWorld_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloWorldServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.HelloWorld/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloWorldServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HelloWorld_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloWorldServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.HelloWorld/Leave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloWorldServer).Leave(ctx, req.(*IdMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _HelloWorld_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IdMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HelloWorldServer).Subscribe(m, &helloWorldSubscribeServer{stream})
}

type HelloWorld_SubscribeServer interface {
	Send(*Notification) error
	grpc.ServerStream
}

type helloWorldSubscribeServer struct {
	grpc.ServerStream
}

func (x *helloWorldSubscribeServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func _HelloWorld_GetNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloWorldServer).GetNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.HelloWorld/GetNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloWorldServer).GetNotification(ctx, req.(*IdMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _HelloWorld_Play_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloWorldServer).Play(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helloworld.HelloWorld/Play",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloWorldServer).Play(ctx, req.(*PlayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HelloWorld_serviceDesc = grpc.ServiceDesc{
	ServiceName: "helloworld.HelloWorld",
	HandlerType: (*HelloWorldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _HelloWorld_Connect_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _HelloWorld_Leave_Handler,
		},
		{
			MethodName: "GetNotification",
			Handler:    _HelloWorld_GetNotification_Handler,
		},
		{
			MethodName: "Play",
			Handler:    _HelloWorld_Play_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _HelloWorld_Subscribe_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x53, 0x4b, 0x4f, 0xe3, 0x30,
	0x10, 0x6e, 0xd2, 0x57, 0x32, 0xad, 0xba, 0x2b, 0x4b, 0xdb, 0x8d, 0xb2, 0xd2, 0x6e, 0x65, 0xed,
	0x81, 0x53, 0x85, 0xe0, 0x00, 0x27, 0xc4, 0x4b, 0x82, 0x4a, 0x80, 0x50, 0x38, 0x20, 0x71, 0xa9,
	0xdc, 0xc4, 0xa5, 0x41, 0x69, 0x1c, 0x12, 0x17, 0xe8, 0x2f, 0x84, 0x9f, 0x45, 0x6c, 0xa7, 0xa9,
	0x03, 0xf4, 0xc0, 0x29, 0x33, 0xdf, 0xcc, 0x7c, 0xf3, 0xf8, 0x1c, 0xf8, 0x39, 0xa3, 0x51, 0xc4,
	0x9e, 0x59, 0x1a, 0x05, 0xc3, 0x24, 0x65, 0x9c, 0x21, 0x58, 0x23, 0xf8, 0x0f, 0xd8, 0xa3, 0xe0,
	0x92, 0x66, 0x19, 0xb9, 0xa7, 0xa8, 0x07, 0x66, 0x18, 0x38, 0xc6, 0xc0, 0xd8, 0x6a, 0x7a, 0xb9,
	0x85, 0xff, 0x43, 0xef, 0x84, 0xc5, 0x31, 0xf5, 0xb9, 0x47, 0x1f, 0x17, 0x34, 0xe3, 0x08, 0x41,
	0x23, 0x26, 0x73, 0x2a, 0x73, 0x6c, 0x4f, 0xda, 0xf8, 0x2f, 0x74, 0xcb, 0xac, 0x24, 0x5a, 0x7e,
	0x62, 0x19, 0x00, 0x5c, 0x50, 0xf2, 0x44, 0x55, 0x34, 0x67, 0xe0, 0x61, 0xc1, 0x50, 0xf7, 0xa4,
	0x8d, 0x5f, 0x0d, 0xe8, 0x5e, 0x31, 0x1e, 0x4e, 0x43, 0x9f, 0xf0, 0x90, 0xc5, 0xe8, 0x1f, 0x74,
	0xe6, 0xe4, 0x65, 0x9c, 0x44, 0x64, 0x49, 0xd3, 0xac, 0xe0, 0x82, 0x1c, 0xba, 0x56, 0x08, 0xca,
	0xc7, 0x8e, 0xcb, 0xb0, 0x29, 0xc3, 0x56, 0xbc, 0x0a, 0xf6, 0xa1, 0xf5, 0xc0, 0xc2, 0x98, 0x06,
	0x4e, 0x5d, 0x8e, 0x59, 0x78, 0xa2, 0x75, 0x44, 0xa7, 0xdc, 0x69, 0xa8, 0xe1, 0x85, 0x8d, 0x1c,
	0x68, 0xcf, 0xd5, 0xf6, 0x4e, 0x53, 0xc2, 0x2b, 0x57, 0xb0, 0x90, 0x05, 0x9f, 0xb1, 0xd4, 0x69,
	0x29, 0x16, 0xe5, 0x89, 0xd6, 0xca, 0x1a, 0xe7, 0x5b, 0xb6, 0x55, 0x6b, 0x05, 0x8c, 0x02, 0xbc,
	0x07, 0x1d, 0x31, 0xc5, 0xea, 0x5c, 0x1f, 0x4e, 0xa1, 0x77, 0x33, 0x2b, 0xdd, 0xf0, 0x11, 0xd8,
	0xaa, 0x50, 0xdc, 0xc8, 0x05, 0x8b, 0xf8, 0x3e, 0x4d, 0x38, 0x55, 0xc5, 0x96, 0x57, 0xfa, 0x9b,
	0x29, 0x76, 0xde, 0x4c, 0x80, 0x73, 0xa1, 0xec, 0xad, 0x50, 0x16, 0x1d, 0x40, 0xbb, 0x90, 0x05,
	0xb9, 0x43, 0xed, 0x0d, 0x54, 0x15, 0x75, 0x7f, 0xe9, 0xb1, 0xf2, 0x29, 0xe0, 0x1a, 0xda, 0x87,
	0xa6, 0x94, 0x0d, 0x7d, 0x9d, 0xe1, 0xf6, 0x75, 0x78, 0x2d, 0x70, 0x5e, 0x79, 0x08, 0xf6, 0xcd,
	0x62, 0x92, 0xf9, 0x69, 0x38, 0xd9, 0x58, 0xed, 0xe8, 0xb0, 0xae, 0x3d, 0xae, 0x6d, 0x1b, 0xe8,
	0x14, 0x7e, 0x9c, 0x51, 0x5e, 0x79, 0x12, 0xdf, 0xe7, 0xc9, 0x37, 0x68, 0x88, 0x9b, 0xa2, 0xdf,
	0x7a, 0x8e, 0x26, 0x4f, 0x75, 0xf7, 0xf2, 0xfc, 0xb8, 0x76, 0x6c, 0xdd, 0xb5, 0xe4, 0xaf, 0x92,
	0x4d, 0xd4, 0x77, 0xf7, 0x3d, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xdc, 0xca, 0xac, 0x46, 0x03, 0x00,
	0x00,
}
